import { SemanticDocument, Block } from './document-model'
import { defaultTOCConfig } from './toc-generator'

/**
 * Automatically inserts a TOC block after the cover section
 */
export const insertAutoTOC = (document: SemanticDocument): SemanticDocument => {
  // Find the cover section (first section or section with "cover" in name)
  const coverSectionIndex = document.sections.findIndex(
    (section, index) => 
      index === 0 || 
      section.name.toLowerCase().includes('cover') ||
      section.name.toLowerCase().includes('title')
  )

  if (coverSectionIndex === -1) {
    // No cover section, insert at the beginning of first section
    return insertTOCInSection(document, 0)
  }

  // Insert TOC at the beginning of the next section after cover
  const targetSectionIndex = Math.min(coverSectionIndex + 1, document.sections.length)
  
  if (targetSectionIndex >= document.sections.length) {
    // Cover is the last section, insert at end of cover section
    return insertTOCInSection(document, coverSectionIndex, 'end')
  }

  return insertTOCInSection(document, targetSectionIndex)
}

/**
 * Insert TOC block in a specific section
 */
const insertTOCInSection = (
  document: SemanticDocument, 
  sectionIndex: number, 
  position: 'start' | 'end' = 'start'
): SemanticDocument => {
  const sections = [...document.sections]
  const targetSection = sections[sectionIndex]
  
  if (!targetSection || targetSection.flows.length === 0) {
    return document
  }

  const tocBlock: Block = {
    id: crypto.randomUUID(),
    type: 'table-of-contents',
    content: {
      ...defaultTOCConfig,
      title: 'Table of Contents',
      includeLevels: [true, true, true, false, false, false], // H1-H3 default
      autoInserted: true
    },
    order: position === 'start' ? -1 : 999999,
    metadata: {
      autoGenerated: true,
      insertionPoint: position,
      sourceSection: targetSection.id
    }
  }

  // Insert in the main flow (first flow)
  const updatedFlows = [...targetSection.flows]
  const mainFlow = updatedFlows[0]
  
  if (mainFlow) {
    const updatedBlocks = [...mainFlow.blocks, tocBlock]
    
    // Reorder blocks if inserting at start
    if (position === 'start') {
      updatedBlocks.sort((a, b) => a.order - b.order)
      // Update orders to maintain sequence
      updatedBlocks.forEach((block, index) => {
        block.order = index
      })
    }

    updatedFlows[0] = {
      ...mainFlow,
      blocks: updatedBlocks
    }
  }

  sections[sectionIndex] = {
    ...targetSection,
    flows: updatedFlows
  }

  return {
    ...document,
    sections
  }
}

/**
 * Check if document already has a TOC block
 */
export const hasTOCBlock = (document: SemanticDocument): boolean => {
  return document.sections.some(section =>
    section.flows.some(flow =>
      flow.blocks.some(block => block.type === 'table-of-contents')
    )
  )
}

/**
 * Remove existing auto-inserted TOC blocks
 */
export const removeAutoTOC = (document: SemanticDocument): SemanticDocument => {
  const sections = document.sections.map(section => ({
    ...section,
    flows: section.flows.map(flow => ({
      ...flow,
      blocks: flow.blocks.filter(block => 
        !(block.type === 'table-of-contents' && block.metadata?.autoGenerated)
      )
    }))
  }))

  return {
    ...document,
    sections
  }
}