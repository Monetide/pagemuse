import { IRDocument, IRSection, IRBlock } from './ir-types'
import { defaultTOCConfig, TOCConfiguration } from './toc-generator'

export interface AutoTOCConfig {
  enabled: boolean
  insertAfterCover: boolean
  insertAfterTitle: boolean
  defaultDepth: 1 | 2 | 3 | 4 | 5 | 6
  includeLevels: boolean[] // [H1, H2, H3, H4, H5, H6]
  columns: 1 | 2
  showPageNumbers: boolean
  pageNumberAlignment: 'right' | 'inline'
  leader: 'dots' | 'dashes' | 'none'
}

export const defaultAutoTOCConfig: AutoTOCConfig = {
  enabled: true,
  insertAfterCover: true,
  insertAfterTitle: false,
  defaultDepth: 3,
  includeLevels: [true, true, true, false, false, false], // H1-H3 by default
  columns: 1,
  showPageNumbers: true,
  pageNumberAlignment: 'right',
  leader: 'dots'
}

export const createTOCBlock = (config: AutoTOCConfig): IRBlock => {
  const tocConfiguration: TOCConfiguration = {
    title: 'Table of Contents',
    includeLevels: config.includeLevels,
    excludeSections: [],
    columns: config.columns,
    columnGap: 0.5,
    showPageNumbers: config.showPageNumbers,
    pageNumberAlignment: config.pageNumberAlignment,
    leader: config.leader,
    indentPerLevel: 0.25,
    itemSpacing: 0.125,
    linkStyle: 'hover',
    autoUpdate: true,
    allowPageBreaks: true,
    showContinued: true
  }

  return {
    id: crypto.randomUUID(),
    type: 'toc',
    content: tocConfiguration,
    order: 1,
    attrs: {
      autoGenerated: true,
      insertedAt: new Date().toISOString(),
      depth: config.defaultDepth
    }
  }
}

export const findCoverSection = (document: IRDocument): IRSection | null => {
  // Look for section with cover-like content
  for (const section of document.sections) {
    const hasTitle = section.blocks.some(block => 
      block.type === 'heading' && 
      (block.attrs?.level === 1 || block.attrs?.isTitle)
    )
    
    const hasAuthorOrDate = section.blocks.some(block =>
      block.type === 'paragraph' && 
      (block.attrs?.isAuthor || block.attrs?.isDate)
    )
    
    if (hasTitle || hasAuthorOrDate) {
      return section
    }
  }
  
  // Fallback to first section
  return document.sections[0] || null
}

export const findTitleSection = (document: IRDocument): IRSection | null => {
  // Look for section with main title (H1)
  for (const section of document.sections) {
    const hasMainTitle = section.blocks.some(block => 
      block.type === 'heading' && block.attrs?.level === 1
    )
    
    if (hasMainTitle) {
      return section
    }
  }
  
  return null
}

export const insertAutoTOC = (document: IRDocument, config: AutoTOCConfig): IRDocument => {
  if (!config.enabled) {
    return document
  }

  let targetSection: IRSection | null = null
  let insertionPoint = 0

  if (config.insertAfterCover) {
    const coverSection = findCoverSection(document)
    if (coverSection) {
      // Find the section after cover
      const coverIndex = document.sections.indexOf(coverSection)
      if (coverIndex >= 0 && coverIndex < document.sections.length - 1) {
        targetSection = document.sections[coverIndex + 1]
        insertionPoint = 0 // Insert at beginning of section
      } else {
        // Create new section after cover
        const newSection: IRSection = {
          id: crypto.randomUUID(),
          title: 'Contents',
          blocks: [],
          order: coverIndex + 1,
          metadata: {
            autoGenerated: true,
            purpose: 'toc'
          }
        }
        
        const updatedSections = [
          ...document.sections.slice(0, coverIndex + 1),
          newSection,
          ...document.sections.slice(coverIndex + 1)
        ]
        
        targetSection = newSection
        insertionPoint = 0
        
        return {
          ...document,
          sections: updatedSections.map(section => 
            section.id === targetSection?.id 
              ? { ...section, blocks: [createTOCBlock(config)] }
              : section
          )
        }
      }
    }
  } else if (config.insertAfterTitle) {
    const titleSection = findTitleSection(document)
    if (titleSection) {
      targetSection = titleSection
      // Find insertion point after title
      const titleIndex = titleSection.blocks.findIndex(block => 
        block.type === 'heading' && block.attrs?.level === 1
      )
      insertionPoint = titleIndex >= 0 ? titleIndex + 1 : 0
    }
  }

  if (!targetSection) {
    // Fallback: insert at beginning of first section
    targetSection = document.sections[0]
    insertionPoint = 0
  }

  if (!targetSection) {
    return document
  }

  // Create TOC block
  const tocBlock = createTOCBlock(config)

  // Insert TOC block at the calculated position
  const updatedBlocks = [
    ...targetSection.blocks.slice(0, insertionPoint),
    tocBlock,
    ...targetSection.blocks.slice(insertionPoint)
  ]

  return {
    ...document,
    sections: document.sections.map(section => 
      section.id === targetSection?.id 
        ? { ...section, blocks: updatedBlocks }
        : section
    )
  }
}

export const hasExistingTOC = (document: IRDocument): boolean => {
  return document.sections.some(section =>
    section.blocks.some(block => block.type === 'toc')
  )
}

export const shouldInsertAutoTOC = (document: IRDocument, config: AutoTOCConfig): boolean => {
  if (!config.enabled) return false
  if (hasExistingTOC(document)) return false
  
  // Check if document has enough headings to warrant a TOC
  const headingCount = document.sections.reduce((count, section) => 
    count + section.blocks.filter(block => block.type === 'heading').length, 0
  )
  
  return headingCount >= 3 // Minimum 3 headings to auto-insert TOC
}