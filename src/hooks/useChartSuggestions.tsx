import { useState, useEffect, useCallback } from 'react'
import { Section, Block } from '@/lib/document-model'
import { detectChartSuggestionsFromDocument, ChartSuggestion, createChartFromSuggestion } from '@/lib/chart-suggestion-detector'

export interface UseChartSuggestionsOptions {
  autoDetect?: boolean
  maxSuggestionsPerTable?: number
  enabledChartTypes?: Array<'bar-vertical' | 'bar-horizontal' | 'line' | 'area' | 'donut'>
}

export const useChartSuggestions = (
  sections: Section[],
  options: UseChartSuggestionsOptions = {}
) => {
  const {
    autoDetect = true,
    maxSuggestionsPerTable = 4,
    enabledChartTypes = ['bar-vertical', 'bar-horizontal', 'line', 'area', 'donut']
  } = options

  const [suggestionsByTable, setSuggestionsByTable] = useState<Map<string, ChartSuggestion[]>>(new Map())
  const [dismissedTables, setDismissedTables] = useState<Set<string>>(new Set())
  const [isAnalyzing, setIsAnalyzing] = useState(false)

  // Detect suggestions when sections change
  useEffect(() => {
    if (!autoDetect || !sections.length) return

    const detectSuggestions = async () => {
      setIsAnalyzing(true)
      try {
        const allSuggestions = detectChartSuggestionsFromDocument(sections)
        
        // Filter suggestions based on enabled chart types and limits
        const filteredSuggestions = new Map<string, ChartSuggestion[]>()
        
        allSuggestions.forEach((suggestions, tableId) => {
          if (dismissedTables.has(tableId)) return
          
          const filtered = suggestions
            .filter(suggestion => enabledChartTypes.includes(suggestion.chartType))
            .slice(0, maxSuggestionsPerTable)
          
          if (filtered.length > 0) {
            filteredSuggestions.set(tableId, filtered)
          }
        })
        
        setSuggestionsByTable(filteredSuggestions)
      } catch (error) {
        console.error('Failed to detect chart suggestions:', error)
      } finally {
        setIsAnalyzing(false)
      }
    }

    // Debounce the detection to avoid excessive calls
    const timeoutId = setTimeout(detectSuggestions, 300)
    return () => clearTimeout(timeoutId)
  }, [sections, autoDetect, enabledChartTypes, maxSuggestionsPerTable, dismissedTables])

  // Get suggestions for a specific table
  const getSuggestionsForTable = useCallback((tableId: string): ChartSuggestion[] => {
    return suggestionsByTable.get(tableId) || []
  }, [suggestionsByTable])

  // Dismiss suggestions for a table
  const dismissSuggestions = useCallback((tableId: string) => {
    setDismissedTables(prev => new Set([...prev, tableId]))
    setSuggestionsByTable(prev => {
      const updated = new Map(prev)
      updated.delete(tableId)
      return updated
    })
  }, [])

  // Re-analyze suggestions (clear dismissed tables and re-run detection)
  const refreshSuggestions = useCallback(() => {
    setDismissedTables(new Set())
    // Effect will re-run due to dismissedTables change
  }, [])

  // Create chart from suggestion
  const createChart = useCallback((
    suggestion: ChartSuggestion,
    sourceTable: Block,
    caption: string,
    altText: string
  ) => {
    try {
      const chartBlock = createChartFromSuggestion(suggestion, sourceTable.content, caption, altText)
      
      // Convert to document model format
      const documentChartBlock: Block = {
        id: chartBlock.id,
        type: 'chart',
        content: chartBlock.content,
        order: sourceTable.order + 1,
        metadata: {
          sourceTableId: suggestion.sourceTableId,
          autoGenerated: true,
          chartType: suggestion.chartType,
          createdAt: new Date().toISOString()
        }
      }
      
      // Auto-dismiss suggestions for this table after successful creation
      dismissSuggestions(suggestion.sourceTableId)
      
      return documentChartBlock
    } catch (error) {
      console.error('Failed to create chart:', error)
      throw new Error('Failed to create chart from suggestion')
    }
  }, [dismissSuggestions])

  // Get summary statistics
  const getStats = useCallback(() => {
    const totalTables = Array.from(suggestionsByTable.keys()).length
    const totalSuggestions = Array.from(suggestionsByTable.values())
      .reduce((sum, suggestions) => sum + suggestions.length, 0)
    const highConfidenceSuggestions = Array.from(suggestionsByTable.values())
      .flat()
      .filter(suggestion => suggestion.confidence >= 0.8).length
    
    return {
      totalTables,
      totalSuggestions,
      highConfidenceSuggestions,
      dismissedCount: dismissedTables.size,
      isAnalyzing
    }
  }, [suggestionsByTable, dismissedTables, isAnalyzing])

  // Check if a table has suggestions
  const hasSuggestions = useCallback((tableId: string): boolean => {
    return suggestionsByTable.has(tableId) && (suggestionsByTable.get(tableId)?.length || 0) > 0
  }, [suggestionsByTable])

  // Get all tables with suggestions
  const getTablesWithSuggestions = useCallback((): string[] => {
    return Array.from(suggestionsByTable.keys())
  }, [suggestionsByTable])

  return {
    suggestionsByTable,
    getSuggestionsForTable,
    dismissSuggestions,
    refreshSuggestions,
    createChart,
    getStats,
    hasSuggestions,
    getTablesWithSuggestions,
    isAnalyzing
  }
}

export default useChartSuggestions